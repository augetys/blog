-- ----------------------------
-- Table structure for blog_article
-- ----------------------------
DROP TABLE IF EXISTS `blog_article`;
CREATE TABLE `blog_article` (
  `id` varchar(64) NOT NULL,
  `title` varchar(200) DEFAULT NULL COMMENT '博客标题',
  `summary` varchar(200) DEFAULT NULL COMMENT '博客简介',
  `admin_id` varchar(36) DEFAULT NULL COMMENT '上传人id',
  `content` longtext DEFAULT NULL COMMENT '博客内容',
  `is_publish` int(1) DEFAULT '1' COMMENT '是否发布：0：否，1：是',
  `tag_id` varchar(255) DEFAULT NULL COMMENT '标签id',
  `cover` varchar(255) DEFAULT NULL COMMENT '封面',
  `click_count` int(11) DEFAULT 0 COMMENT '博客点击数',
  `is_original` int(1) DEFAULT '1' COMMENT '是否原创（0:不是 1：是）',
  `author` varchar(255) DEFAULT NULL COMMENT '作者',
  `articles_part` varchar(255) DEFAULT NULL COMMENT '文章出处',
  `category_id` varchar(32) DEFAULT NULL COMMENT '博客分类ID',
  `sort` int(11) DEFAULT 0 COMMENT '排序字段',
  `open_comment` tinyint(1) DEFAULT 1 COMMENT '是否开启评论(0:否 1:是)',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='博客文章表';

INSERT INTO `blog_article` VALUES ('0cde4db22cac5a4893a660ea2b673c10', 'ArraryList', NULL, '', '## 前言\n\n面试的时候别人经常会将arrayList linkedList进行对比，大部分人会回答arrayList底层是集合，查询块增删慢，linkedlist 底层是链表查询慢增删块，确定是这样么？\n\n## 特性\n\n进入arraylist源码首先会看到arraylist继承AbstractList这是模版模式，然后实现List,mRandomAccess, Cloneable, java.io.Serializable这是为什么？\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n\n```\n\n#### RandomAccess（标志接口）\n\n打开源码，发现接口里面什么也没有，这是个空的接口，并且是1.4才引入的\n\n```java\n * @since 1.4\n */\npublic interface RandomAccess {\n}\n```\n\n通过官网的API，我才知道，原来这是一个标志接口，下面引入一段官网的原文：\npublic interface RandomAccess\nMarker interface used by List implementations to indicate that they support fast (generally constant time) random access.\n这段话大概的意思就是说 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。也就是说，实现了这个接口的集合是支持 快速随机访问 策略的。\n\n同时，官网还特意说明了，如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。\n\n#### Cloneable（标志接口）\n\nCloneable标记接口，只有实现这个接口后，然后在类中重写Object中的clone方法，然后通过类调用clone方法才能克隆成功，如果不实现这个接口，则会抛出CloneNotSupportedException(克隆不被支持)异常。\n\n```java\n/**\n * A class implements the <code>Cloneable</code> interface to\n * indicate to the {@link java.lang.Object#clone()} method that it\n * is legal for that method to make a\n * field-for-field copy of instances of that class.\n * <p>\n * Invoking Object\'s clone method on an instance that does not implement the\n * <code>Cloneable</code> interface results in the exception\n * <code>CloneNotSupportedException</code> being thrown.\n * <p>\n * By convention, classes that implement this interface should override\n * <tt>Object.clone</tt> (which is protected) with a public method.\n * See {@link java.lang.Object#clone()} for details on overriding this\n * method.\n * <p>\n * Note that this interface does <i>not</i> contain the <tt>clone</tt> method.\n * Therefore, it is not possible to clone an object merely by virtue of the\n * fact that it implements this interface.  Even if the clone method is invoked\n * reflectively, there is no guarantee that it will succeed.\n *\n * @author  unascribed\n * @see     java.lang.CloneNotSupportedException\n * @see     java.lang.Object#clone()\n * @since   JDK1.0\n */\npublic interface Cloneable {\n}\n\n```\n\n- 浅拷贝\n\n```java\npublic Object clone() throws CloneNotSupportedException {\n    Study s = (Study) super.clone();\n    return s;\n}\n```\n\n被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。\n简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200906155157953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODQzMDM3,size_16,color_FFFFFF,t_70#pic_center)\n\n- 深拷贝\n\n```java\npublic Object clone() throws CloneNotSupportedException {\n    Study s = (Study) super.clone();\n    s.setScore(this.score.clone());\n    return s;\n}\n```\n\n深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。\n简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200906155234759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODQzMDM3,size_16,color_FFFFFF,t_70#pic_center)\n\n#### Serializable\n\n序列化反序列化：将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据，在Java中的这个Serializable接口其实是给jvm看的，通知jvm，我不对这个类做序列化了，你(jvm)帮我序列化就好了。\n\nserialVersionUID：如果我们没有自己声明一个serialVersionUID变量,接口会默认生成一个serialVersionUID，默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常（每次序列化都会重新计算该值）\n\ntransient：使用transient关键字修饰的的变量，在序列化对象的过程中，该属性不会被序列化。\n\n#### 实现List为什么？\n\nAbstractList中实现了List\n\n```java\npublic abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n```\n\n```java\n在StackOverFlow 中：传送门 得票最高的答案的回答者说他问了当初写这段代码的 Josh Bloch，得知这就是一个写法错误。\nI’ve asked Josh Bloch, and he informs me that it was a mistake. He used to think, long ago, that there was some value in it,\nbut he since “saw the light”. Clearly JDK maintainers haven’t considered this to be worth backing out later.\n```\n\n## 源码\n\n#### 基本属性\n\n- private static final long serialVersionUID =\n  8683452581122892189L;//序列化版本号（类文件签名），如果不写会默认生成，类内容的改变会影响签名变化，导致反序列化失败\n- private static final int DEFAULT_CAPACITY =\n  10;//如果实例化时未指定容量，则在初次添加元素时会进行扩容使用此容量作为数组长度\n- private static final Object[] EMPTY_ELEMENTDATA = {};\n- private static final Object[]\n  static修饰，所有的未指定容量的实例(也未添加元素)共享此数组，两个空的数组有什么区别呢？ 就是第一次添加元素时知道该 elementData 从空的构造函数还是有参构造函数被初始化的。以便确认如何扩容。空的构造器则初始化为10，有参构造器则按照扩容因子扩容\n- DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n- transient Object[] elementData; // arrayList真正存放元素的地方，长度大于等于size\n- private int size;//arrayList中的元素个数\n\n## 构造器\n\n当使用无参构造函数时是把 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 赋值给 elementData。 当 initialCapacity 为零时则是把 EMPTY_ELEMENTDATA 赋值给 elementData。 当 initialCapacity 大于零时初始化一个大小为 initialCapacity 的 object 数组并赋值给 elementData。\n\n```java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n```\n\n无参构造器，构造一个容量大小为 10 的空的 list 集合，但构造函数只是给 elementData 赋值了一个空的数组，其实是在第一次添加元素时容量扩大至 10 的\n\n```java\npublic ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n```\n\n将 Collection 转化为数组，数组长度赋值给 size。 如果 size 不为零，则判断 elementData 的 class 类型是否为 ArrayList，不是的话则做一次转换。 如果 size 为零，则把 EMPTY_ELEMENTDATA 赋值给 elementData，相当于new ArrayList(0)。\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\n## 尾部添加元素\n\n每次添加元素到集合中时都会先确认下集合容量大小。然后将 size 自增 1赋值\n\n```java\npublic boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n判断如果 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 就取 DEFAULT_CAPACITY 和 minCapacity 的最大值也就是 10。这就是 EMPTY_ELEMENTDATA 与 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的区别所在。同时也验证了上面的说法：使用无参构造函数时是在第一次添加元素时初始化容量为 10 的\n\n```java\n private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        return minCapacity;\n    }\n\n    private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n```\n\n对modCount自增1，记录操作次数，如果 minCapacity 大于 elementData 的长度，则对集合进行扩容,第一次添加元素时 elementData 的长度为零\n\n```java\nprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n```\n\n涉及扩容，会消耗性能，但是如果提前指定容量，会提升性能，可以达到与linkedList相当，甚至超越\n\n```java\npublic void addEffect(){\n    //不指定下标插入\n    int length = 10000000;\n    List al = new ArrayList(length);//指定容量时   效率相当\n    List ll = new LinkedList();\n    long start5 = System.currentTimeMillis();\n    for(int i=0;i <length;i++){\n        al.add(i);\n    }\n    long end5 = System.currentTimeMillis();\n    System.out.println(end5-start5);\n    long start6 = System.currentTimeMillis();\n    for(int i=0;i <length;i++){\n        ll.add(i);\n    }\n    long end6 = System.currentTimeMillis();\n    System.out.println(end6-start6);\n}\n```\n\n执行结果：\n912\n4237\n\n## 指定下标添加元素\n\n时间复杂度为O(n)，与移动的元素个数正相关\n\n```java\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);//下标越界检查\n    ensureCapacityInternal(size + 1);  //同上  判断扩容,记录操作数\n    //依次复制插入位置及后面的数组元素，到后面一格，不是移动，因此复制完后，添加的下标位置和下一个位置指向对同一个对象\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    elementData[index] = element;//再将元素赋值给该下标\n    size++;\n}\n```\n\n## 扩容\n\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;//获取当前数组长度\n    int newCapacity = oldCapacity + (oldCapacity >> 1);//默认将扩容至原来容量的 1.5 倍\n    if (newCapacity - minCapacity < 0)//如果1.5倍太小的话，则将我们所需的容量大小赋值给newCapacity\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)//如果1.5倍太大或者我们需要的容量太大，那就直接拿 newCapacity = (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE 来扩容\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);//然后将原数组中的数据复制到大小为 newCapacity 的新数组中，并将新数组赋值给 elementData。\n}\n```\n\n## 删除元素\n\n- remove(int index)\n\n```java\npublic E remove(int index) {\n    rangeCheck(index);//首先会检查 index 是否合法\n    modCount++;//操作数+1\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)//判断要删除的元素是否是最后一个位,如果 index 不是最后一个，就从 index + 1 开始往后所有的元素都向前拷贝一份。然后将数组的最后一个位置空,如果 index 是最后一个元素那么就直接将数组的最后一个位置空\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; //让指针最后指向空，进行垃圾回收\n    return oldValue;\n}\n```\n\n- remove(Object o)\n  当我们调用 remove(Object o) 时，会把 o 分为是否为空来分别处理。然后对数组做遍历，找到第一个与 o 对应的下标 index，然后调用 fastRemove 方法，删除下标为 index 的元素\n\n```java\npublic boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n```\n\n- fastRemove(int index)\n  fastRemove(int index) 方法和 remove(int index) 方法基本全部相同\n\n```java\nprivate void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n```\n\n## 迭代器iterator\n\n```java\npublic Iterator<E> iterator() {\n    return new Itr();\n}\nprivate class Itr implements Iterator<E> {\n    int cursor;       // 代表下一个要访问的元素下标\n    int lastRet = -1; // 代表上一个要访问的元素下标\n    int expectedModCount = modCount;//代表对 ArrayList 修改次数的期望值，初始值为 modCount\n    //如果下一个元素的下标等于集合的大小 ，就证明到最后了\n    public boolean hasNext() {\n        return cursor != size;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public E next() {\n        checkForComodification();//判断expectedModCount和modCount是否相等,ConcurrentModificationException\n        int i = cursor;\n        if (i >= size)//对 cursor 进行判断，看是否超过集合大小和数组长度\n            throw new NoSuchElementException();\n        Object[] elementData = ArrayList.this.elementData;\n        if (i >= elementData.length)\n            throw new ConcurrentModificationException();\n        cursor = i + 1;//自增 1。开始时，cursor = 0，lastRet = -1；每调用一次next方法，cursor和lastRet都会自增1。\n        return (E) elementData[lastRet = i];//将cursor赋值给lastRet，并返回下标为 lastRet 的元素\n    }\n    public void remove() {\n        if (lastRet < 0)//判断 lastRet 的值是否小于 0\n            throw new IllegalStateException();\n        checkForComodification();//判断expectedModCount和modCount是否相等,ConcurrentModificationException\n        try {\n            ArrayList.this.remove(lastRet);//直接调用 ArrayList 的 remove 方法删除下标为 lastRet 的元素\n            cursor = lastRet;//将 lastRet 赋值给 curso\n            lastRet = -1;//将 lastRet 重新赋值为 -1，并将 modCount 重新赋值给 expectedModCount。\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n    final void checkForComodification() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n}\n```\n\nIterator 支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。这样做的好处是可以避免 ConcurrentModifiedException ，这个异常顾名思意：当打开 Iterator 迭代集合时，同时又在对集合进行修改。\n有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。\n\nremove 方法的弊端。\n1、只能进行remove操作，add、clear 等 Itr 中没有。\n2、调用 remove 之前必须先调用 next。因为 remove 开始就对 lastRet 做了校验。而 lastRet 初始化时为 -1。\n3、next 之后只可以调用一次 remove。因为 remove 会将 lastRet 重新初始化为 -1\n\n面试题：\n对集合的删除为什么要使用迭代器？\n\n## 不可变集合\n\n```java\nCollections.unmodifiableList可以将list封装成不可变集合（只读），但实际上会受源list的改变影响\npublic void unmodifiable() {\n    List list = new ArrayList(Arrays.asList(4,3,3,4,5,6));//缓存不可变配置\n    List modilist = Collections.unmodifiableList(list);//只读\n    modilist.set(0,1);//会报错UnsupportedOperationException\n    //modilist.add(5,1);\n    list.set(0,1);\n    System.out.println(modilist.get(0));//打印1\n}\n```\n\n## Arrays.asList\n\n```java\npublic void testArrays(){\n    long[] arr = new long[]{1,4,3,3};\n    List list = Arrays.asList(arr);//基本类型不支持泛型化，会把整个数组当成一个元素放入新的数组，传入可变参数\n    System.out.println(list.size());//打印1\n}\n//可变参数\npublic static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n}\n```\n\n（1）该方法适用于对象型数据的数组（String、Integer...）\n（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）\n（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新\n（4）不支持add()、remove()、clear()等方法\n\n## Lists.newArrayList\n\nLists.newArrayList() 其实和 new ArrayList() 几乎一模一样, 唯一它帮你做的(其实是javac帮你做的), 就是自动推导(不是\"倒\")尖括号里的数据类型。Lists是一个工具类，同样的Maps也是一个工具类，同样也可以这么使用。\n\n## 什么是fail-fast\n\nail-fast机制是java集合中的一种错误机制。\n\n当使用迭代器迭代时，如果发现集合有修改，则快速失败做出响应，抛出ConcurrentModificationException异常。\n\n这种修改有可能是其它线程的修改，也有可能是当前线程自己的修改导致的，比如迭代的过程中直接调用remove()删除元素等。\n\n另外，并不是java中所有的集合都有fail-fast的机制。比如，像最终一致性的ConcurrentHashMap、CopyOnWriterArrayList等都是没有fast-fail的。\n\nfail-fast是怎么实现的：\nArrayList、HashMap中都有一个属性叫modCount，每次对集合的修改这个值都会加1，在遍历前记录这个值到expectedModCount中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。\n', 1, '4338a8bc2afbb095169b03c291e0b8ff,62edf1de6f1bc800d3350da3dfd9e479', 'http://photo.choot.top/20210729085839401.jpg', 0, 1, NULL, NULL, 'code', 0, 1, '2021-07-29 08:58:50', '2021-07-29 08:58:50');
INSERT INTO `blog_article` VALUES ('a201923ba970cec68afe92709f0cd82a', '测试', NULL, '测试markdown渲染', '# 111111\n\n###### 6666666666\n\n*斜体斜体斜体斜体*\n\n~~删除线删除线删除线删除线~~\n\n[百度](http://baidu.com)\n\n* 111\n* 222\n* 333\n* 444\n\n1. 一\n2. 二\n3. 三\n4. 四\n\n* [ ] 任务一\n* [ ] 任务二\n* [ ] 任务三\n* [ ] 任务四\n\n> 引用引用引用引用引用引用引用引用引用引用引用\n\n---\n\n```\n    /**\n     * 查询分页数据\n     */\n    @ApiOperation(value = \"查询分页数据\")\n    @PostMapping(value = \"/list\")\n    public CommonResult<CommonPage<BlogArticle>> findListByPage(@ApiParam @RequestBody BlogArticleSearchRequestDto blogArticleSearchRequestDto) {\n        Page<BlogArticle> list = iBlogArticleService.findListByPage(blogArticleSearchRequestDto);\n        return CommonResult.success(CommonPage.restPage(list));\n    }\n```\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n| 1    | 2    | 3    |\n| 4    | 5    | 8    |\n', 1, '4338a8bc2afbb095169b03c291e0b8ff,7193b408d6ef276b9906d0147064fdbf', 'http://photo.choot.top/2021072818362344.jpg', 0, 1, NULL, NULL, 'note', 0, 1, '2021-07-28 08:00:00', '2021-07-28 18:37:17');
INSERT INTO `blog_article` VALUES ('be2530b7680b22eadb400906d89f4048', 'LinkedList', NULL, 'LinkedList', '## 特性\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n{}\n\npublic abstract class AbstractSequentialList<E> extends AbstractList<E> {}\n\npublic interface Deque<E> extends Queue<E> {}\n```\n\n- 继承于 AbstractSequentialList ，本质上面与继承 AbstractList没有什么区别，AbstractSequentialList 完善了 AbstractList 中没有实现的方法。\n- List，Cloneable，Serializable前面讲过\n- Deque：实现了Collection 大家庭中的队列接口，说明他拥有作为双端队列的功能。LinkedList与ArrayList最大的区别就是LinkedList中实现了Collection中Queue（Deque）接口 拥有作为双端队。\n\n## 基本属性\n\n链表没有长度限制，他的内存地址不需要分配固定长度进行存储，只需要记录下一个节点的存储地址即可完成整个链表的连续。\n\n```java\n//当前有多少个结点，元素个数\ntransient int size = 0;\n//第一个结点\ntransient Node<E> first;\n//最后一个结点\ntransient Node<E> last;\n//Node的数据结构\nprivate static class Node<E> {\n    E item;//存储元素\n    Node<E> next;//后继\n    Node<E> prev;//前驱\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nLinkedList 在1.6 版本以及之前，只通过一个 header 头指针保存队列头和尾。这种操作可以说很有深度，但是从代码阅读性来说，却加深了阅读代码的难度。因此在后续的JDK 更新中，将头节点和尾节点 区分开了。节点类也更名为 Node。\n\n为什么Node这个类是静态的？答案是：这跟内存泄露有关，Node类是在LinkedList类中的，也就是一个内部类，若不使用static修饰，那么Node就是一个普通的内部类，在java中，一个普通内部类在实例化之后，默认会持有外部类的引用，这就有可能造成内存泄露（内部类与外部类生命周期不一致时）。但使用static修饰过的内部类（称为静态内部类），就不会有这种问题。\n\n非静态内部类会自动生成一个构造器依赖于外部类：也是内部类可以访问外部类的实例变量的原因，静态内部类不会生成，访问不了外部类的实例变量，只能访问类变量。\n\n## 构造器\n\n```java\n /**\n     * Constructs an empty list.\n     */\n    public LinkedList() {\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\'s\n     * iterator.\n     *\n     * @param  c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);//操作次数只会记录一次   设置前驱后继\n    }\n```\n\n## 添加元素\n\n```java\npublic boolean add(E e) {\n     linkLast(e);\n     return true;\n }\n//目标节点创建后寻找前驱节点， 前驱节点存在就修改前驱节点的后继，指向目标节点\nvoid linkLast(E e) {\n    final Node<E> l = last;//获取这个list对象内部的Node类型成员last，即末位节点，以该节点作为新插入元素的前驱节点\n    final Node<E> newNode = new Node<>(l, e, null);//创建新节点\n    last = newNode;//把新节点作为该list对象的最后一个节点\n    if (l == null)//处理原先的末位节点，如果这个list本来就是一个空的链表\n        first = newNode;//把新节点作为首节点\n    else\n        l.next = newNode;//如果链表内部已经有元素，把原来的末位节点的后继指向新节点，完成链表修改\n    size++;//修改当前list的size，\n    modCount++;//并记录该list对象被执行修改的次数\n}\npublic void add(int index, E element) {\n    checkPositionIndex(index);//检查下标的合法性\n    if (index == size)//插入位置是末位，那还是上面末位添加的逻辑\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\nNode<E> node(int index) {\n    if (index < (size >> 1)) {//二分查找   index离哪端更近 就从哪端开始找\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;//找到index位置的元素\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n//指位添加方法核心逻辑  操作新节点，紧接修改原有节点的前驱属性，最后再修改前驱节点的后继属性\nvoid linkBefore(E e, Node<E> succ) {\n    final Node<E> pred = succ.prev;//原位置节点的前驱pred\n    final Node<E> newNode = new Node<>(pred, e, succ);//创建新节点,设置新节点其前驱为原位置节点的前驱pred，其后继为原位置节点succ\n    succ.prev = newNode;//将新节点设置到原位置节点的前驱\n    if (pred == null)//前驱如果为空，空链表，则新节点设置为first\n        first = newNode;\n    else\n        pred.next = newNode;//将新节点设置到前驱节点的后继\n    size++;//修改当前list的size\n    modCount++;//记录该list对象被执行修改的次数。\n}\npublic boolean addAll(int index, Collection<? extends E> c) {\n    checkPositionIndex(index);\n    //将集合转化为数组\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n    Node<E> pred, succ;\n    //获取插入节点的前节点（prev）和尾节点（next）\n    if (index == size) {\n        succ = null;\n        pred = last;\n    } else {\n        succ = node(index);\n        pred = succ.prev;\n    }\n    //将集合中的数据编织成链表\n    for (Object o : a) {\n        @SuppressWarnings(\"unchecked\") E e = (E) o;\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n    //将 Collection 的链表插入 LinkedList 中。\n    if (succ == null) {\n        last = pred;\n    } else {\n        pred.next = succ;\n        succ.prev = pred;\n    }\n    size += numNew;\n    modCount++;\n    return true;\n}\n```\n\nfinal修饰，不希望在运行时对变量做重新赋值\nLinkedList 在插入数据优于ArrayList ，主要是因为他只需要修改指针的指向即可，而不需要将整个数组的数据进行转移。而LinkedList 由于没有实现 RandomAccess，或者说不支持索引搜索的原因，他在查找元素这一操作，需要消耗比较多的时间进行操作（n/2）。\n\n## 删除元素\n\n#### AbstractSequentialList的remove\n\n```java\npublic E remove(int index) {\n    checkElementIndex(index);\n    //node(index)找到index位置的元素\n    return unlink(node(index));\n}\n//remove(Object o)这个删除元素的方法的形参o是数据本身，而不是LinkedList集合中的元素（节点），所以需要先通过节点遍历的方式，找到o数据对应的元素，然后再调用unlink(Node x)方法将其删除\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nE unlink(Node<E> x) {\n    //x的数据域element\n    final E element = x.item;\n    //x的下一个结点\n    final Node<E> next = x.next;\n    //x的上一个结点\n    final Node<E> prev = x.prev;\n    //如果x的上一个结点是空结点的话，那么说明x是头结点\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;//将x的前后节点相连   双向链表\n        x.prev = null;//x的属性置空\n    }\n    //如果x的下一个结点是空结点的话，那么说明x是尾结点\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;//将x的前后节点相连   双向链表\n        x.next = null;\n    }\n    x.item = null;//指向null  方便GC回收\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n#### Deque 中的Remove\n\n```java\n//将first 节点的next 设置为新的头节点，然后将 f 清空。 removeLast 操作也类似。\nprivate E unlinkFirst(Node<E> f) {\n    final E element = f.item;\n    //获取到头结点的下一个结点         \n    final Node<E> next = f.next;\n    f.item = null;\n    f.next = null; // 方便 GC\n    //头指针指向的是头结点的下一个结点\n    first = next;\n    //如果next为空，说明这个链表只有一个结点\n    if (next == null)\n        last = null;\n    else\n        next.prev = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n## 双端链表（队列Queue）\n\njava中队列的实现就是LinkedList： 我们之所以说LinkedList 为双端链表，是因为他实现了Deque 接口；我们知道，队列是先进先出的，添加元素只能从队尾添加，删除元素只能从队头删除，Queue中的方法就体现了这种特性。 支持队列的一些操作，我们来看一下有哪些方法实现：\n• pop（）是栈结构的实现类的方法，返回的是栈顶元素，并且将栈顶元素删除\n• poll（）是队列的数据结构，获取对头元素并且删除队头元素\n• push（）是栈结构的实现类的方法，把元素压入到栈中\n• peek（）获取队头元素 ，但是不删除队列的头元素\n• offer（）添加队尾元素\n可以看到Deque 中提供的方法主要有上述的几个方法，接下来我们来看看在LinkedList 中是如何实现这些方法的。\n\n#### 队列的增加\n\noffer（）添加队尾元素\n\n```java\npublic boolean offer(E e) {\n    return add(e);\n}\n```\n\n具体的实现就是在尾部添加一个元素\n\n#### 队列的删\n\npoll（）是队列的数据结构，获取对头元素并且删除队头元素\n\n```java\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n```\n\n具体的实现前面已经讲过，删除的是队列头部的元素\n\n#### 队列的查\n\npeek（）获取队头元素 ，但是不删除队列的头元素\n\n```java\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n```\n\n#### 栈的增\n\npush（）是栈结构的实现类的方法，把元素压入到栈中\npush（） 方法的底层实现，其实就是调用了 addFirst（Object o）\n\n```java\npublic void push(E e) {\n    addFirst(e);\n}\n```\n\n#### 栈的删\n\npop（）是栈结构的实现类的方法，返回的是栈顶元素，并且将栈顶元素删除\n\n```java\npublic E pop() {\n    return removeFirst();\n}\npublic E removeFirst() {\n    final Node f = first;\n    if (f == null)\n    throw new NoSuchElementException();\n    return unlinkFirst(f);\n}\n```\n', 1, '4338a8bc2afbb095169b03c291e0b8ff,e7cb6f8a0e571e32ea5d372c6f0493dd', 'http://photo.choot.top/20210729085708657.jpg', 0, 0, NULL, NULL, 'think', 0, 1, '2021-07-29 08:57:16', '2021-07-29 08:57:16');

-- ----------------------------
-- Table structure for blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `blog_tag`;
CREATE TABLE `blog_tag` (
  `id` varchar(64) NOT NULL,
  `name` varchar(255) DEFAULT NULL COMMENT '标签内容',
  `icon` varchar(255) DEFAULT NULL COMMENT '标签图标',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `sort` int(11) NULL DEFAULT 0 COMMENT '排序',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='博客标签表';

INSERT INTO `blog_tag` VALUES ('3bfb57eb21eeac3e3f49370e936bbcf7', 'linux', 'icon-linux', '2021-07-29 10:23:36', '2021-07-29 10:23:36', 3);
INSERT INTO `blog_tag` VALUES ('4338a8bc2afbb095169b03c291e0b8ff', '面试', 'icon-interview', '2021-07-29 10:27:20', '2021-07-29 10:27:20', 5);
INSERT INTO `blog_tag` VALUES ('61bd0d34e03ae3038cb4168be8f67893', '股票', 'icon-banking', '2021-07-29 10:22:45', '2021-07-29 10:22:45', 2);
INSERT INTO `blog_tag` VALUES ('62edf1de6f1bc800d3350da3dfd9e479', 'java', 'icon-java', '2021-07-02 08:00:00', '2021-07-29 10:21:12', 1);
INSERT INTO `blog_tag` VALUES ('7193b408d6ef276b9906d0147064fdbf', 'vue', 'icon-vue', '2021-07-29 10:26:56', '2021-07-29 10:26:56', 4);
INSERT INTO `blog_tag` VALUES ('e7cb6f8a0e571e32ea5d372c6f0493dd', 'Think', 'icon-xingqiu', '2021-07-29 08:00:00', '2021-07-29 10:30:07', 7);
INSERT INTO `blog_tag` VALUES ('f62f8f1730f0d8241367258ec3d69c39', '旅行', 'icon-travel', '2021-07-29 10:28:04', '2021-07-29 10:28:04', 6);


-- ----------------------------
-- Table structure for blog_category
-- ----------------------------
DROP TABLE IF EXISTS `blog_category`;
CREATE TABLE `blog_category` (
  `id` varchar(64) NOT NULL,
  `name` varchar(255) DEFAULT NULL COMMENT '分类内容',
  `content` varchar(255) DEFAULT NULL COMMENT '分类简介',
  `sort` int(11) NULL DEFAULT 0 COMMENT '排序',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='博客分类表';

INSERT INTO `blog_category` VALUES ('code', '代码', '前后端开发技术', 3, '2021-07-02 08:00:00', '2021-07-29 10:20:27');
INSERT INTO `blog_category` VALUES ('note', '笔记', '学习笔记', 1, '2021-07-02 13:55:33', '2021-07-02 13:55:33');
INSERT INTO `blog_category` VALUES ('think', '思考', '思考人生', 5, '2021-07-29 10:19:48', '2021-07-29 10:19:48');



-- ----------------------------
-- Table structure for blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `blog_comment`;
CREATE TABLE `blog_comment` (
  `id` varchar(64) NOT NULL,
  `content` varchar(1000) DEFAULT NULL COMMENT '评论内容',
  `user_id` varchar(64) DEFAULT NULL COMMENT '评论用户',
  `user_avatar` varchar(1024) DEFAULT NULL COMMENT '评论用户头像',
  `article_id` varchar(64) DEFAULT NULL COMMENT '博客文章id',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='博客文章评论表';

-- ----------------------------
-- Table structure for blog_replay
-- ----------------------------
DROP TABLE IF EXISTS `blog_replay`;
CREATE TABLE `blog_replay` (
  `id` varchar(64) NOT NULL,
  `content` varchar(1000) DEFAULT NULL COMMENT '回复内容',
  `user_id` varchar(64) DEFAULT NULL COMMENT '回复用户',
  `comment_id` varchar(64) DEFAULT NULL COMMENT '回复评论id',
  `article_id` varchar(64) DEFAULT NULL COMMENT '博客文章id',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='博客文章回复表';

-- ----------------------------
-- Table structure for tb_looper
-- ----------------------------
DROP TABLE IF EXISTS `blog_loop`;
CREATE TABLE `blog_loop` (
  `id` varchar(64) NOT NULL COMMENT 'ID',
  `title` varchar(128) NOT NULL COMMENT '轮播图标题',
  `sort` int(11) NOT NULL DEFAULT 0 COMMENT '顺序',
  `is_link` int(11) NOT NULL DEFAULT 0 COMMENT '是否外链 0 否 1 是',
  `target_url` varchar(1024) DEFAULT NULL COMMENT '目标URL',
  `image_url` varchar(2014) NOT NULL COMMENT '图片地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=INNODB CHARSET=utf8mb4 COMMENT='轮播图';

INSERT INTO `blog_loop` VALUES ('4f5710d7bfa908c1f92bfd5f1f5e97b3', '呜呜呜呜我我', 5, 0, '/article/0cde4db22cac5a4893a660ea2b673c10', 'http://photo.choot.top/pexels-photo-1346295.jpeg', '2021-07-28 08:00:00', '2021-08-06 15:00:10');
INSERT INTO `blog_loop` VALUES ('58627203626381717ea3a47766a5fa35', '哈哈哈', 2, 0, '/article/a201923ba970cec68afe92709f0cd82a', 'http://photo.choot.top/pexels-photo-1472887.jpeg', '2021-07-28 08:00:00', '2021-08-06 15:00:46');
INSERT INTO `blog_loop` VALUES ('7382725c2dfa596b92c86efc2d356b11', '嫩恩恩额', 4, 0, '/article/be2530b7680b22eadb400906d89f4048', 'http://photo.choot.top/pexels-photo-1184000.jpeg', '2021-07-28 08:00:00', '2021-08-06 15:14:23');
INSERT INTO `blog_loop` VALUES ('7cfe21e91d8f12f8877f1cafd9491699', '恩恩额恩恩', 3, 1, 'https://www.baidu.com/', 'http://photo.choot.top/pexels-photo-3824139.jpeg', '2021-07-28 08:00:00', '2021-08-06 15:14:38');
INSERT INTO `blog_loop` VALUES ('8d972bef3ab84331d7779f7d0302341b', '呜呜呜', 1, 1, 'https://www.baidu.com/', 'http://photo.choot.top/pexels-photo-7103949.jpeg', '2021-07-28 08:00:00', '2021-08-06 15:14:53');

-- ----------------------------
-- Table structure for tb_looper
-- ----------------------------
DROP TABLE IF EXISTS `blog_nav`;
CREATE TABLE `blog_nav` (
  `id` varchar(64) NOT NULL COMMENT 'ID',
  `name` varchar(128) NOT NULL COMMENT '导航名称',
  `icon` varchar(128) NOT NULL COMMENT '导航图标',
  `sort` int(11) DEFAULT 1 COMMENT '导航排序',
  `path` varchar(128) NOT NULL COMMENT '跳转路由',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=INNODB CHARSET=utf8mb4 COMMENT='导航';

INSERT INTO `blog_nav` VALUES ('1', '醉花阴', 'icon-home', 1, '/', '2021-07-28 09:02:42', '2021-07-28 09:02:46');
INSERT INTO `blog_nav` VALUES ('10', '海市蜃楼', 'icon-video', 10, '/', '2021-07-28 09:05:18', '2021-07-28 09:05:20');
INSERT INTO `blog_nav` VALUES ('2', '无妄海', 'icon-code', 2, '/category/code', '2021-07-28 09:03:03', '2021-07-28 09:03:06');
INSERT INTO `blog_nav` VALUES ('3', '清平乐', 'icon-think', 3, '/category/think', '2021-07-28 09:03:19', '2021-07-28 09:03:21');
INSERT INTO `blog_nav` VALUES ('4', '如梦令', 'icon-life', 4, '/category/note', '2021-07-28 09:03:37', '2021-07-28 09:03:40');
INSERT INTO `blog_nav` VALUES ('5', '荏苒', 'icon-date', 5, '/', '2021-07-28 09:03:54', '2021-07-28 09:03:58');
INSERT INTO `blog_nav` VALUES ('6', '琉璃镜', 'icon-photo', 6, '/', '2021-07-28 09:04:14', '2021-07-28 09:04:16');
INSERT INTO `blog_nav` VALUES ('7', '藏经阁', 'icon-file', 7, '/', '2021-07-28 09:04:31', '2021-07-28 09:04:33');
INSERT INTO `blog_nav` VALUES ('8', '山外小楼', 'icon-guestbook', 8, '/', '2021-07-28 08:00:00', '2021-07-29 10:00:39');
INSERT INTO `blog_nav` VALUES ('9', '天命风流', 'icon-personInfo', 9, '/', '2021-07-28 08:00:00', '2021-07-29 10:00:31');

commit;